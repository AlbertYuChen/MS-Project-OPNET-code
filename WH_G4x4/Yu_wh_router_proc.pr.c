/* Process model C form file: Yu_wh_router_proc.pr.c */
/* Portions of this file copyright 1986-2011 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from Yu_wh_router_proc.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char Yu_wh_router_proc_pr_c [] = "MIL_3_Tfile_Hdr_ 171A 30A modeler 7 5537F318 5537F318 1 ECE-PHO309-01 chenyua 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 2b1a 1                                                                                                                                                                                                                                                                                                                                                                                                    ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

// include files
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <direct.h>

/*
define the interrupt codes here
*/
#define SA_FLIT_INTRPT_CODE 1000
#define ID_DONE_INTRPT_CODE 1001

// define FLIT_ARRIVAL, stream interrupt within the node
#define FLIT_ARRIVAL (op_intrpt_type () == OPC_INTRPT_STRM)

// check the adjacent nodes
#define SA_FLIT (op_intrpt_type () == OPC_INTRPT_STRM)

// ACK remote intrpt from adjacent node
#define ACK (op_intrpt_type () == OPC_INTRPT_REMOTE)

// PSQUEUE_READY signal
#define PSQUEUE_READY (op_intrpt_type () == OPC_INTRPT_STAT)

// define the time out handler
#define TIME_OUT (op_intrpt_type () == OPC_INTRPT_SELF)

// define the time out handler
#define ID_DONE (op_intrpt_type () == OPC_INTRPT_SELF)

// define flit type here
#define Flit_Type_Data_Flit 0
#define Flit_Type_Dest_Addr 1
#define Flit_Type_Src_Addr 2
#define Flit_Type_Worm_Length 6
#define Flit_Type_Tail 7

// read the node specified routing table here
#define ID_STREAM get_id_stream();

// flit handler when a flit is arriving
#define HANDLE_FLIT flit_handler();

// ACK handler
#define HANDLE_ACK ACK_handler();

// handler swire when PSQueue is ready
#define HANDLE_SWIRE SWIRE_handler();

// 
#define HANDLE_TIMER router_handle_time_out();

//
#define TEST_ID_DONE test_ID_DONE();

// out PORT is Busy or not
#define OUT_PORT_BUSY 1
#define OUT_PORT_FREE 0

// IN_PORT_table
#define IN_PORT_FLIT_ARRIVED 3
#define IN_PORT_NEXT_NODE_BUSY 0
#define IN_PORT_NEXT_NODE_READY 1

// IS_SINK_READY
#define SINK_READY 1
#define SINK_BUSY 0

// contain_DHF
#define CONTAIN_DHF 1
#define NOT_CONTAIN_DHF 0


// timeout time
#define TIME_OUT_TIME 10




/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Stathandle	             		PGQ_RT_ACK                                      ;	/* this is the stat variable, or the stat signal between PGQ and router */
	Packet **	              		inport_flit_buffer                              ;	/* this is the one flit register for all port, since the size is fixed   */
	                        		                                                	/* I used the array here rarther than a queue. When a flit comes, if the */
	                        		                                                	/* out port is free and the input sign bit shows the next node is ready, */
	                        		                                                	/* then send the flit directly,                                          */
	int **	                 		Routing_Table                                   ;	/* The router table for each node. It get initialized in the Identify status. */
	                        		                                                	/* Once it has been initialied, it will never be changed.                     */
	int *	                  		Neighbor_PORT_NODE_map                          ;	/* This shows the map of each node. Since the node in the network is short-sighted, */
	                        		                                                	/* it need more information about the neighbor nodes. This is the map between       */
	                        		                                                	/* the port and the directly connected node.                                        */
	                        		                                                	/* Once it's been set, it will never changed in the network.                        */
	int *	                  		combined_output_port                            ;	/* This is a dynamic variable for each port. It shows the bind relation between */
	                        		                                                	/* the input port and the output port. This get set once the DHF is sending,    */
	                        		                                                	/* and get erased when the TF is being sent.                                    */
	int *	                  		combined_input_port                             ;	/* This is a dynamic variable show the combined relation between the input port                              */
	                        		                                                	/* and output port when transmiting a worm.                                                                  */
	                        		                                                	/* It's get set when the DHF is sending. This may happed in flit_handler() is sending the arriving DHF,      */
	                        		                                                	/* when ACK is sending the waiting DHF in the flit register, or when SWIRE_Handler is sending the DHF in the */
	                        		                                                	/* register.                                                                                                 */
	int	                    		Total_Node_Num                                  ;	/* This is a static variable get initailized in the routing map loader function. */
	int	                    		This_Node_Number                                ;	/* Static variable, get initailized in the routing map loader function */
	int	                    		Max_Deg                                         ;	/* This get initialied in the initialer() function, and this is a key value */
	                        		                                                	/* for the memory allocation, and state variables:                          */
	                        		                                                	/*                                                                          */
	                        		                                                	/* Neighbor_PORT_NODE_map                                                   */
	                        		                                                	/* OUT_PORT_table                                                           */
	                        		                                                	/* combined_input_port                                                      */
	                        		                                                	/* inport_flit_buffer                                                       */
	                        		                                                	/* IN_PORT_table                                                            */
	                        		                                                	/* combined_output_port                                                     */
	                        		                                                	/* contain_DHF                                                              */
	                        		                                                	/* DHF_buffer_time                                                          */
	int	                    		head_flit_counter                               ;	/* Dynamic variable, get increase in the flit_handler() function. Whenever */
	                        		                                                	/* there comes the flit, it get increased                                  */
	int *	                  		DHF_buffer_time                                 ;	/* As there will be several flits DHFs waiting to be sent, we are using    */
	                        		                                                	/* FIFO strategy for those DHF. Here is simplify our work, we at first use */
	                        		                                                	/* sim_time, but then change to flit counter.                              */
	                        		                                                	/* Used to put the sim_time() of DHF, this variable get set when DHF are   */
	                        		                                                	/* blocked, and stored in the local regster, waiting to be sent if there's */
	                        		                                                	/* no traffic. when several DHF are going to be sent, they will compare    */
	                        		                                                	/* the DHF_buffer_time to sent the first come flit.                        */
	int *	                  		OUT_PORT_table                                  ;	/* this is used engage the outport for every worm when a router is transforming */
	                        		                                                	/* a worm. It will be set to BUSY when the DHF is sending, and set to free      */
	                        		                                                	/* when the tail flit is sending.                                               */
	int *	                  		contain_DHF                                     ;	/* This is used for searching for waiting DHF flits waiting in inport_flit_buffer */
	                        		                                                	/* , it will be set to BUSY when the DHF arrives in the buffer, and set to        */
	                        		                                                	/* free when the DHF is going to be sent                                          */
	int *	                  		IN_PORT_table                                   ;	/* This is a dynamic variable. It has three status: BUSY, Nest_Node_Ready,      */
	                        		                                                	/* Flit_Arrived. It will be initialied to Nest_Node_Ready in the beginning.     */
	                        		                                                	/* Once it sends a flit and waiting for the comming back ACK, the input port    */
	                        		                                                	/* will be BUSY. When the input port is BUSY, but there comes a flit, which     */
	                        		                                                	/* means the next node is not well prepared, so the comming flit will be        */
	                        		                                                	/* store in the buffer, and the sign bit will be set to Arrived. When the ACK   */
	                        		                                                	/* signal come back, it will take care of the the waiting flit. If the ACK come */
	                        		                                                	/* back with the input port status BUSY, it will set the BUSY to Ready.         */
	int	                    		stat_counter                                    ;	/* since the stat variable need to be changed whenever you want to send a */
	                        		                                                	/* stat signal, so this variable is used for this usage, it get increase  */
	                        		                                                	/* before the stat signal is sent                                         */
	Objid *	                		Neighbor_PORT_NODE_proc_Objid_map               ;
	int	                    		flit_timer                                      ;
	int *	                  		flit_timer_recorder                             ;
	} Yu_wh_router_proc_state;

#define PGQ_RT_ACK              		op_sv_ptr->PGQ_RT_ACK
#define inport_flit_buffer      		op_sv_ptr->inport_flit_buffer
#define Routing_Table           		op_sv_ptr->Routing_Table
#define Neighbor_PORT_NODE_map  		op_sv_ptr->Neighbor_PORT_NODE_map
#define combined_output_port    		op_sv_ptr->combined_output_port
#define combined_input_port     		op_sv_ptr->combined_input_port
#define Total_Node_Num          		op_sv_ptr->Total_Node_Num
#define This_Node_Number        		op_sv_ptr->This_Node_Number
#define Max_Deg                 		op_sv_ptr->Max_Deg
#define head_flit_counter       		op_sv_ptr->head_flit_counter
#define DHF_buffer_time         		op_sv_ptr->DHF_buffer_time
#define OUT_PORT_table          		op_sv_ptr->OUT_PORT_table
#define contain_DHF             		op_sv_ptr->contain_DHF
#define IN_PORT_table           		op_sv_ptr->IN_PORT_table
#define stat_counter            		op_sv_ptr->stat_counter
#define Neighbor_PORT_NODE_proc_Objid_map		op_sv_ptr->Neighbor_PORT_NODE_proc_Objid_map
#define flit_timer              		op_sv_ptr->flit_timer
#define flit_timer_recorder     		op_sv_ptr->flit_timer_recorder

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	Yu_wh_router_proc_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((Yu_wh_router_proc_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

// used for sending flits at the beginning stage, to get the connetion relation with neighbor nodes
Packet * r_generate_flit(int type, int data){
	Packet * pkptr;
	
	FIN(generate_flit());
	
	pkptr = op_pk_create_fmt("Yu_wh_pkformat");
	op_pk_nfd_set(pkptr, "type", type);
	op_pk_nfd_set(pkptr, "data", data);
	
	FRET(pkptr);
}

// this is used for debug usage, need to uniform all type to int if possible.
void test_ID_DONE(void){
	int i;
	
	FIN(test_ID_DONE());
	
	if (op_prg_odb_ltrace_active ("IDDONE") == OPC_TRUE){
		printf("ID_DONE@%d\n", This_Node_Number);
		for (i = 0; i <= Max_Deg; i++) {
			printf("Neighbor_PORT_NODE_map: %d  <---->  %d\n", i, Neighbor_PORT_NODE_map[i]);
		}
		
		for (i = 0; i <= Max_Deg; i++) {
			printf("OUT_PORT_table: %d  <---->  %d\n", i, OUT_PORT_table[i]);
		}
		
	}
	FOUT;
}

// load AR node table
void load_ARnode_routing_table(void) {

	Objid myObjid, parentObjid;
	char parentname[64];
	char RName[128];
	FILE * Rinfile;
	char lbuf[2048];
	char * nToken;

	int i;
	int row;
	int col;
	int dest_port;
	
	FIN(load_ARnode_routing_table());
	
	// get the local node number
	myObjid = op_id_self();
	parentObjid = op_topo_parent (myObjid);
	op_ima_obj_attr_get (parentObjid, "name", &parentname);
	This_Node_Number = atoi(&parentname[5]);
	
	// get the routing table file path
	sprintf(RName, "C:\\Users\\chenyua\\OPNET_Project\\WH\\ARnode_%d.txt", This_Node_Number);  // <<<<--------------change work path here
	if (!(Rinfile = fopen(RName, "r"))) {
		printf("load_ARnode_routing_table: could not find file");
		exit(-2);
	}
	
	fgets(lbuf, 2048, Rinfile);
	nToken = strtok(lbuf, " \t\n");
	Total_Node_Num = atoi(nToken);
	nToken = strtok(NULL, " \t\n");
	Max_Deg = atoi(nToken);
	
	// printf("Node@%d  Total_Node_Num: %d  Max_Deg: %d\n",This_Node_Number, Total_Node_Num, Max_Deg);
	
	// the reason for adding one here is that the port includes the PSQueue port, i.e. port #0	
	Routing_Table = (int **)op_prg_mem_alloc( (Max_Deg + 1)* sizeof(int *));
	for (i = 0; i <= Max_Deg; i++) {
		Routing_Table[i] = (int *)op_prg_mem_alloc(Total_Node_Num * sizeof(int));
	}
	
	row = 0;
	while(fgets(lbuf, 2048, Rinfile)){
		// printf("lind: %s", lbuf);
		nToken = strtok(lbuf, " ] [ ");
		
		for (col = 0; col < Total_Node_Num; col++) {
			
			dest_port = atoi(nToken);
			Routing_Table[row][col] = dest_port;
			
			if (op_prg_odb_ltrace_active ("RTAR") == OPC_TRUE){
				printf("%3d", Routing_Table[row][col]);
				if(col == Total_Node_Num - 1){
					printf("\nrow:%d  col:%d\n", row, col);
				}
			}
			nToken = strtok(NULL, " ] [ ");	
		}
		row++;
	}
	FOUT;
}

void load_Rnode_routing_table(void) {

	Objid myObjid, parentObjid;
	char parentname[64];
	char RName[128];
	FILE * Rinfile;
	char lbuf[2048];
	char * nToken;

	int i;
	int row;
	int col;
	int dest_port;
	
	FIN(load_ARnode_routing_table());
	
	// get the local node number
	myObjid = op_id_self();
	parentObjid = op_topo_parent (myObjid);
	op_ima_obj_attr_get (parentObjid, "name", &parentname);
	This_Node_Number = atoi(&parentname[5]);
	
	// get the routing table file path
	sprintf(RName, "C:\\Users\\chenyua\\OPNET_Project\\WH_G4x4\\Rnode_%d.txt", This_Node_Number);  // <<<<--------------change work path here
	if (!(Rinfile = fopen(RName, "r"))) {
		printf("load_Rnode_routing_table: could not find file");
		exit(-2);
	}
	
	fgets(lbuf, 2048, Rinfile);
	nToken = strtok(lbuf, " \t\n");
	Total_Node_Num = atoi(nToken);
	nToken = strtok(NULL, " \t\n");
	Max_Deg = atoi(nToken);
	
	// printf("Node@%d @router Total_Node_Num: %d  Max_Deg: %d\n",This_Node_Number, Total_Node_Num, Max_Deg);
	
	// the reason for adding one here is that the port includes the PSQueue port, i.e. port #0	
	Routing_Table = (int **)op_prg_mem_alloc( (Max_Deg + 1)* sizeof(int * ));
	for (i = 0; i <= Max_Deg; i++) {
		Routing_Table[i] = (int *)op_prg_mem_alloc(Total_Node_Num * sizeof(int));
	}
	
	row = 0;
	while(fgets(lbuf, 2048, Rinfile)){
		// printf("lind: %s", lbuf);
		nToken = strtok(lbuf, " ");
		
		for (col = 0; col < Total_Node_Num; col++) {
			
			dest_port = atoi(nToken);
			Routing_Table[row][col] = dest_port;
			
			if (op_prg_odb_ltrace_active ("RTR") == OPC_TRUE){
				printf("%3d", Routing_Table[row][col]);
				if(col == Total_Node_Num - 1){
					printf("\nrow:%d  col:%d\n", row, col);
				}
			}
			nToken = strtok(NULL, " ");	
		}
		row++;
	}
	FOUT;
}

void send_remote_intrpt_to_adjacent_node(void){
	
	Packet * pkptr;
	int strm_pt;
	
	FIN(send_remote_intrpt_to_adjacent_node());
	
	for (strm_pt = 2; strm_pt <= Max_Deg + 1; strm_pt++) {
	//for (strm_pt = 2; strm_pt <= 2; strm_pt++) {
		pkptr = r_generate_flit(Flit_Type_Src_Addr, This_Node_Number);				
		op_pk_send(pkptr, strm_pt);
	}
	
	FOUT;
}

void initialize_router(void){
	
	int i;
	
	FIN(initialize_router());

	head_flit_counter = 0;
	flit_timer = 0;
	stat_counter = 0;

	// call the routing table initializer here
	
	// if(This_Node_Number == 0)
	// load_ARnode_routing_table();
	load_Rnode_routing_table();
	
	
	// connection neighbor map	
	Neighbor_PORT_NODE_map = (int *)op_prg_mem_alloc((Max_Deg + 1) * sizeof(int));
	Neighbor_PORT_NODE_proc_Objid_map = (Objid *)op_prg_mem_alloc((Max_Deg + 1) * sizeof(Objid));
	
	// output ports and associate output port structures
	OUT_PORT_table = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));
	combined_input_port = (int *)op_prg_mem_alloc((Max_Deg + 1) * sizeof(int));
	
	// input ports and associate input port structures
	inport_flit_buffer = (Packet **)op_prg_mem_alloc((Max_Deg + 1)* sizeof(Packet *));
	IN_PORT_table = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));	
	combined_output_port = (int *)op_prg_mem_alloc((Max_Deg + 1) * sizeof(int));
	contain_DHF = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));
	DHF_buffer_time = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));
	
	flit_timer_recorder = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));
	
	// initialize the variables
	for (i = 0; i <= Max_Deg; i++) {
		Neighbor_PORT_NODE_map[i] = -1;
		Neighbor_PORT_NODE_proc_Objid_map[i] = -1;
			
		OUT_PORT_table[i] = OUT_PORT_FREE;
		combined_input_port[i] = -1;
		
		
		IN_PORT_table[i] = IN_PORT_NEXT_NODE_READY;
		DHF_buffer_time[i] = INT_MAX;
		combined_output_port[i] = -1;
		inport_flit_buffer[i] = NULL;
		contain_DHF[i] = NOT_CONTAIN_DHF;
		
		flit_timer_recorder[i] = -1;
		
	}
	
	Neighbor_PORT_NODE_map[0] = This_Node_Number;
			
	// send the source head flit to adjacent nodes, they will get the connection status
	send_remote_intrpt_to_adjacent_node();

	FOUT;
}

// get node attribution in Identify state
// get the neighbors ID
void get_id_stream(void) {

	Packet * pkptr;
	int type;
	int data;
	int strm_port_number;
	char neighbor_node_name[32];
	Objid next_node_objid, next_proc_objid;
	
	FIN(get_id_stream());
	
	strm_port_number = op_intrpt_strm ();
	
	pkptr = op_pk_get (strm_port_number);
	op_pk_nfd_get(pkptr, "type", &type);
	op_pk_nfd_get(pkptr, "data", &data);
	
	
	if (op_prg_odb_ltrace_active ("SA") == OPC_TRUE && This_Node_Number == 1){
		printf("R_Node:%d @router strm@%d: type:%d data:%d\n", This_Node_Number, strm_port_number, type, data);
		printf("node@%d intrpt node:%d\n", This_Node_Number, data);
	}
	
	// the real #port = #stream - 1
	Neighbor_PORT_NODE_map[strm_port_number - 1] = data;
	
	
	sprintf(neighbor_node_name, "node_%d", data);
	next_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, neighbor_node_name);
	next_proc_objid = op_id_from_name (next_node_objid, OPC_OBJTYPE_PROC, "router");
	Neighbor_PORT_NODE_proc_Objid_map[strm_port_number - 1] = next_proc_objid;
	
			

	// schedule a self interrupt to move to Listening status
	op_intrpt_schedule_self (op_sim_time (), 0);

	FOUT;
}

// functions for Listerning
void flit_handler(void){
	Packet * pkptr;

	int tmp_type;
	int tmp_data;
	int forward_strm_number;
	int forward_port_number;
	int input_strm_number;
	int input_port_number;
	int waiting_port;
	int i;
	int waiting_port_forward_port_number;
	
	int min_DHF_time = INT_MAX;

//	int coming_node_number;
//	char coming_node_name[32];
//	Objid neighbor_node_objid, neighbor_proc_objid;
//	Objid next_node_objid, next_proc_objid;
	
	FIN(flit_handler());

	flit_timer++;
	
	input_strm_number = op_intrpt_strm();
	input_port_number = (input_strm_number == 0 ? 0 : input_strm_number - 1);
	
	pkptr = op_pk_get(input_strm_number);
	op_pk_nfd_get(pkptr, "type", &tmp_type);
	op_pk_nfd_get(pkptr, "data", &tmp_data);
	
	if (op_prg_odb_ltrace_active ("LS") == OPC_TRUE){
		
	
		printf("node:%d @flit_handler time:  %12f  #input_port_number#%d  status:%d type:%d data:%d\n", 
			This_Node_Number, op_sim_time(), input_port_number, IN_PORT_table[input_port_number], tmp_type, tmp_data);
	}
	

	// call other procedures that handle individual flit types
	if(tmp_type == Flit_Type_Dest_Addr) {

		forward_port_number = Routing_Table[input_port_number][tmp_data];		
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);

		// when DHF arrives, it can only be sent if the outport is free and the input port register is ready for the next flit
		if(OUT_PORT_table[forward_port_number] == OUT_PORT_FREE){
			
			op_pk_send(pkptr, forward_strm_number);	
			
			// when the DHF is being sent, the linked path of this node need to be changed
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			OUT_PORT_table[forward_port_number] = OUT_PORT_BUSY;
			combined_output_port[input_port_number] = forward_port_number;
			combined_input_port[forward_port_number] = input_port_number;	
			
			
			// after sending the flit, it need to inform the previous node, i'm OK for next flit, the previous may be PGQ or a node
			if(input_strm_number == 0){
				stat_counter++;
				op_stat_write (PGQ_RT_ACK, stat_counter);
			}else{
				op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, Neighbor_PORT_NODE_proc_Objid_map[input_port_number]);
			}
	
		}
		// else if it's busy, keep the header flit in a register
		else{
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			printf("++++++++++++++++++++Node:%d Port:%d is busy  from port:%d   OUT_PORT_table[]%d  IN_PORT_table[]%d\n", 
				This_Node_Number, forward_port_number, input_port_number, OUT_PORT_table[forward_port_number], IN_PORT_table[input_port_number]);
			}
			
			
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
			
			DHF_buffer_time[input_port_number] = ++head_flit_counter;
			contain_DHF[input_port_number] = CONTAIN_DHF;
			
			
			if(combined_input_port[forward_port_number] == -1){

				// contain_DHF[input_port_number] = NOT_CONTAIN_DHF;
				// DHF_buffer_time[input_port_number] = INT_MAX;
				
				combined_output_port[input_port_number] = forward_port_number;	
				combined_input_port[forward_port_number] = input_port_number;
				
			}
			/*  */
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			
			printf("++++++++++++++++++++Node:%d Port:%d is busy  from port:%d   OUT_PORT_table[]%d  IN_PORT_table[]%d\n", 
				This_Node_Number, forward_port_number, input_port_number, OUT_PORT_table[forward_port_number], IN_PORT_table[input_port_number]);
			
			
			for (i = 0; i <= Max_Deg; i++) {
				printf("Node:%d  contain_DHF[%d]=%d  DHF_buffer_time:%d \n", This_Node_Number, i, contain_DHF[i], DHF_buffer_time[i]);
			}
			
			for (i = 0; i <= Max_Deg; i++) {
				printf("Node:%d  OUT_PORT_table[%d]=%d\n",This_Node_Number, i, OUT_PORT_table[i]);
			}
			
			for (i = 0; i <= Max_Deg; i++) {		
				printf("contain_DHF: %d  <---->  %d  time:%d  OUT_PORT_table: %d \n", i, contain_DHF[i], DHF_buffer_time[i], OUT_PORT_table[i]);
			}
			
			for (i = 0; i <= Max_Deg; i++) {		
				printf("%d  <----> combined_output_port:%d  combined_input_port:%d\n", i, combined_output_port[i], combined_input_port[i]);
			}
			
			}
			
			if (op_prg_odb_ltrace_active ("SI") == OPC_TRUE){
			// printf("Trigger a self interrupt Node:%d from port:%d to %d\n", This_Node_Number, input_port_number, forward_port_number);
			flit_timer_recorder[input_port_number] = flit_timer;
			op_intrpt_schedule_self (op_sim_time () +  TIME_OUT_TIME, (flit_timer<<20) + (tmp_data<<12) + (tmp_type<<8) + (input_port_number<<4) + forward_port_number);
			}
		}
	// else if it's not busy, then the input port it came from is associated with the 
	// output port and binding takes place
	}else if(tmp_type == Flit_Type_Src_Addr) {

		forward_port_number = combined_output_port[input_port_number];
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);
	
		if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
			// op_pk_send(pkptr, 0);
			op_pk_send(pkptr, forward_strm_number);

			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;

			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, Neighbor_PORT_NODE_proc_Objid_map[input_port_number]);
			
		}else if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_BUSY){
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
			
			if (op_prg_odb_ltrace_active ("SI") == OPC_TRUE){
			flit_timer_recorder[input_port_number] = flit_timer;
			op_intrpt_schedule_self (op_sim_time () +  TIME_OUT_TIME, (flit_timer<<20) + (tmp_data<<12) + (tmp_type<<8) + (input_port_number<<4) + forward_port_number);
			}
		}
		else {
			printf("ERROR: Node:%d inputport data type is wrong\n", This_Node_Number, tmp_type, tmp_data);
			op_sim_end("Simulation is stopped","","","");
		}

	}else if(tmp_type == Flit_Type_Worm_Length) {

		forward_port_number = combined_output_port[input_port_number];
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);
	
		if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
			// op_pk_send(pkptr, 0);
			op_pk_send(pkptr, forward_strm_number);
			
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			/*
			coming_node_number = Neighbor_PORT_NODE_map[input_port_number];
			sprintf(coming_node_name, "node_%d", coming_node_number);
			neighbor_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, coming_node_name);
			neighbor_proc_objid = op_id_from_name (neighbor_node_objid, OPC_OBJTYPE_PROC, "router");
			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, neighbor_proc_objid);
			*/
			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, Neighbor_PORT_NODE_proc_Objid_map[input_port_number]);
			
			
		}else if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_BUSY){
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
			
			if (op_prg_odb_ltrace_active ("SI") == OPC_TRUE){
			flit_timer_recorder[input_port_number] = flit_timer;
			op_intrpt_schedule_self (op_sim_time () +  TIME_OUT_TIME, (flit_timer<<20) + (tmp_data<<12) + (tmp_type<<8) + (input_port_number<<4) + forward_port_number);
			}
		}
		else {
			printf("ERROR: Node:%d inputport data type is wrong\n", This_Node_Number, tmp_type, tmp_data);
			op_sim_end("Simulation is stopped","","","");
		}
	}else if(tmp_type == Flit_Type_Data_Flit) {	
		
		forward_port_number = combined_output_port[input_port_number];
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);

		
		if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
			// op_pk_send(pkptr, 0);
			op_pk_send(pkptr, forward_strm_number);
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, Neighbor_PORT_NODE_proc_Objid_map[input_port_number]);
		}else if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_BUSY){
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
			
			if (op_prg_odb_ltrace_active ("SI") == OPC_TRUE){
			flit_timer_recorder[input_port_number] = flit_timer;
			op_intrpt_schedule_self (op_sim_time () +  TIME_OUT_TIME, (flit_timer<<20) + (tmp_data<<12) + (tmp_type<<8) + (input_port_number<<4) + forward_port_number);
			}
		}
		else {
			printf("ERROR: Node:%d inputport data type is wrong\n", This_Node_Number, tmp_type, tmp_data);
			op_sim_end("Simulation is stopped","","","");
		}
	}
	// tail flit
	else if(tmp_type == Flit_Type_Tail) {	
	
		forward_port_number = combined_output_port[input_port_number];
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);

		// if the next node comes, there are a lot of cases to deal
		if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
		
		
			// if the TF is going to be sent, it need to clean some status, but PAY ATTENTION!!!, the combined_input_port is going to 
			// be cleaned by the ACK, because, if you clean the combined_input_port, right now, other flit may insert the queue
		
			op_pk_send(pkptr, forward_strm_number);
			
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_READY;
			// OUT_PORT_table[forward_port_number] = OUT_PORT_FREE;
			combined_output_port[input_port_number] = -1;
			combined_input_port[forward_port_number] = -1;
			inport_flit_buffer[input_port_number] = NULL;
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			printf("*****************Node:%d, port: 0  forward_port_number:%d\n", This_Node_Number, forward_port_number);
			}
			
			// now find the next waiting head flit in the buffers
			min_DHF_time = INT_MAX;
			waiting_port = -1;
			for (i = 0; i <= Max_Deg; i++) {
				if(contain_DHF[i] == CONTAIN_DHF){
				
					pkptr = inport_flit_buffer[i];
					op_pk_nfd_get(pkptr, "type", &tmp_type);
					op_pk_nfd_get(pkptr, "data", &tmp_data);
					
					waiting_port_forward_port_number = Routing_Table[i][tmp_data];	
					
					if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
					printf("*** %d <---> tmp_type:%d  tmp_data:%d\n", i, tmp_type, tmp_data);
					}
					
					if(waiting_port_forward_port_number == forward_port_number && tmp_type == Flit_Type_Dest_Addr  && min_DHF_time > DHF_buffer_time[i]){
						min_DHF_time =  DHF_buffer_time[i];
						waiting_port = i;
					}
				}
			}
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
		
			printf("*****************  waiting_port  %d\n", waiting_port);
			
			for (i = 0; i <= Max_Deg; i++) {
				printf("contain_DHF: %d  <---->  %d  time:%d  OUT_PORT_table: %d \n", i, contain_DHF[i], DHF_buffer_time[i], OUT_PORT_table[i]);
			}
			
			}
			
			// found the waint port number now.
			// if there exits a waiting DHF
			if (waiting_port != -1) {	
				
				if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			 	printf("*********** waiting_port:%d type:%d data:%d  min_DHF_time:%d  forward_port_number:%d\n",
					waiting_port, tmp_type, tmp_data, min_DHF_time, forward_port_number);	
				}
				
				// initialize the new status
				IN_PORT_table[waiting_port] = IN_PORT_FLIT_ARRIVED;

				OUT_PORT_table[forward_port_number] = OUT_PORT_BUSY;
				combined_output_port[waiting_port] = forward_port_number;	
				combined_input_port[forward_port_number] = waiting_port;

			}
				
			// after sendint the TF, need to send handshak signal to the previous node or PGQ
			if(input_port_number == 0){
				stat_counter++;
				op_stat_write (PGQ_RT_ACK, stat_counter);
			}
			
			else{
				op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, Neighbor_PORT_NODE_proc_Objid_map[input_port_number]);
			}

			
		}else if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_BUSY){
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
			
			if (op_prg_odb_ltrace_active ("SI") == OPC_TRUE){
			flit_timer_recorder[input_port_number] = flit_timer;
			op_intrpt_schedule_self (op_sim_time () +  TIME_OUT_TIME, (flit_timer<<20) + (tmp_data<<12) + (tmp_type<<8) + (input_port_number<<4) + forward_port_number);
			}
		}
		
		else {
			printf("ERROR: Node:%d inputport data type is wrong\n", This_Node_Number, tmp_type, tmp_data);
			op_sim_end("Simulation is stopped","","","");
		}
	}else{
		printf("ERROR:pkptr  node:%d @flit_handler #input_port_number#%d  type:%d data:%d\n", This_Node_Number, input_port_number, tmp_type, tmp_data);
	}
	FOUT;
}

void ACK_handler(void) {

	int src_intrpt_node_number;
	int intrpt_port;
	int send_strm;
	int my_combined_input_port;
//	int next_node_number;
	int tmp_type;
	int tmp_data;
//	char next_node_name[64];
	int waiting_port_forward_port_number;
	
	Packet * pkptr;
//	Objid next_node_objid, next_proc_objid;
	
	int min_DHF_time;
	int waiting_port;
	int i;
// 	int forward_strm_number;
//	int forward_port_number;

	
	FIN(ACK_handler());
	
	
	// from now on, find the comming signal and correspond port
	
	src_intrpt_node_number = op_intrpt_code();
	
	if (op_prg_odb_ltrace_active ("ACK") == OPC_TRUE){
		printf("ACK  Node:%d receive from Node:%d \n", This_Node_Number, src_intrpt_node_number);
	}
	
	for (intrpt_port = 0; intrpt_port <= Max_Deg; intrpt_port++) {
		if(Neighbor_PORT_NODE_map[intrpt_port] == src_intrpt_node_number) {
			break;
		}
	}
	
	send_strm = (intrpt_port == 0 ? 0 : intrpt_port + 1);
	my_combined_input_port = combined_input_port[intrpt_port];
	
	if(my_combined_input_port == -1){
		if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
	 	printf("====================================== ACK Node:%d  intrpt_port:%d my_combined_input_port:%d  = -1\n", This_Node_Number, intrpt_port, my_combined_input_port);
		}
		
		OUT_PORT_table[intrpt_port] = OUT_PORT_FREE;
		FOUT;
	}
	
	// found out all possible information
	
	flit_timer_recorder[my_combined_input_port] = -1;
	
	// if the input port is busy, then, modify that to ready when the last node send me a signal
	if(IN_PORT_table[my_combined_input_port] == IN_PORT_NEXT_NODE_BUSY){
		IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_READY;
		
		if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
		printf("????????????????????BUSY --> READY intrpt_port %d  my_combined_input_port %d input_port_status:%d\n", 
			intrpt_port, my_combined_input_port, IN_PORT_table[my_combined_input_port]);
		}
	} 
	
	// before the handshaking signal comes, if a flit has already came, then directly take care of the flit
	else if(IN_PORT_table[my_combined_input_port] == IN_PORT_FLIT_ARRIVED){
		// printf("@@@@@@@@@@@@@@@@@@@@ intrpt_port %d  my_combined_input_port %d input_port_status:%d\n", 
			// intrpt_port, my_combined_input_port, IN_PORT_table[my_combined_input_port]);

		pkptr = inport_flit_buffer[my_combined_input_port];
		
		op_pk_nfd_get(pkptr, "type", &tmp_type);
		op_pk_nfd_get(pkptr, "data", &tmp_data);
		

		// if the waiting flit is DHF, then need to clean the old status and change some new information
		if(tmp_type == Flit_Type_Dest_Addr){

			
			DHF_buffer_time[my_combined_input_port] = INT_MAX;
			contain_DHF[my_combined_input_port] = NOT_CONTAIN_DHF;
						
			combined_output_port[my_combined_input_port] = intrpt_port;
			combined_input_port[intrpt_port] = my_combined_input_port;
			
		
			op_pk_send(pkptr, send_strm);
			inport_flit_buffer[my_combined_input_port] = NULL;
			IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_BUSY;
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^@ACK   send DHF  at Node%d from Port:%d  to  port:%d \n", 
				This_Node_Number, my_combined_input_port, intrpt_port);
			}
		}
		
		// if the waiting flit is TF, then, need to do more thing, very similar to the flit_handler() part
		else if(tmp_type == Flit_Type_Tail){
			op_pk_send(pkptr, send_strm);
			IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_BUSY;
		
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			printf("////-----Node %d  prepare next DHF #intrpt_port:%d\n", This_Node_Number, intrpt_port);
			}
			
			// now find the next head flit in the buffers
			min_DHF_time = INT_MAX;
			waiting_port = -1;
			
			
			inport_flit_buffer[my_combined_input_port] = NULL;
			combined_input_port[intrpt_port] = -1;
			IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_READY;
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			for (i = 0; i <= Max_Deg; i++) {		
				printf("contain_DHF: %d  <---->  %d  time:%d  OUT_PORT_table: %d \n", i, contain_DHF[i], DHF_buffer_time[i], OUT_PORT_table[i]);
			}
			}
			
			
			for (i = 0; i <= Max_Deg; i++) {
				if(contain_DHF[i] == CONTAIN_DHF){
				
					pkptr = inport_flit_buffer[i];
					op_pk_nfd_get(pkptr, "type", &tmp_type);
					op_pk_nfd_get(pkptr, "data", &tmp_data);
					
					waiting_port_forward_port_number = Routing_Table[i][tmp_data];	
					
					// printf("port%d type:%d  data:%d\n", i, tmp_type, tmp_data);
					
					if(waiting_port_forward_port_number == intrpt_port && tmp_type == Flit_Type_Dest_Addr  && min_DHF_time > DHF_buffer_time[i]){
						min_DHF_time =  DHF_buffer_time[i];	
						waiting_port = i;
					}

				}
			}
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			printf("////////////////////////  waiting_port  %d\n", waiting_port);
			}

			
			if (waiting_port != -1) {
				if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
				printf("/////////// waiting_port:%d min_DHF_time:%d  type:%d data:%d  intrpt_port:%d\n",
					 waiting_port, min_DHF_time, tmp_type, tmp_data,  intrpt_port);		
				}

				
				IN_PORT_table[waiting_port] = IN_PORT_FLIT_ARRIVED;
								
				combined_output_port[waiting_port] = intrpt_port;	
				combined_input_port[intrpt_port] = waiting_port;
				
				if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
				printf("////////////////////////  Node%d change input port from %d to %d\n", This_Node_Number, my_combined_input_port, waiting_port);
				}
			}
			
			
		}else{
			op_pk_send(pkptr, send_strm);
			inport_flit_buffer[my_combined_input_port] = NULL;
			IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_BUSY;
		
		}
		
		
		if(my_combined_input_port == 0){
			stat_counter++;
			op_stat_write (PGQ_RT_ACK, stat_counter);
			
		}else{
			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, Neighbor_PORT_NODE_proc_Objid_map[my_combined_input_port]);
		}
	
	}
	
	FOUT;
}

// this function is very similar to the ACK_handler, but it's for PSQ's stat wire signal
void SWIRE_handler(void){

	int input_port_number;
	
	
	int tmp_type;
	int tmp_data;
	Packet * pkptr;

	int min_DHF_time;
	int waiting_port;
	
//	int next_node_number;
//	char next_node_name[32];
	int i;
	
//	int forward_port_number;
//	int forward_strm_number;
	
//	Objid next_node_objid, next_proc_objid;
	int waiting_port_forward_port_number;
	
	
	FIN(SWIRE_handler());
	
	input_port_number = combined_input_port[0];
	
	if(input_port_number == -1){
		if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
		printf("==================-----------------input_port_number == -1  @NOde%d\n", This_Node_Number);
		}
		
		OUT_PORT_table[0] = OUT_PORT_FREE;
		
		FOUT;
	}

	flit_timer_recorder[input_port_number] = -1;
	
	if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_BUSY){
		IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_READY;
		if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
		printf("xxxxxxxxxxxxxxxx  Node:%d WIRE PORT:%d  BUSY --> READY \n", This_Node_Number, input_port_number);
		}
	} 
	
	else if(IN_PORT_table[input_port_number] == IN_PORT_FLIT_ARRIVED){
		
		pkptr = inport_flit_buffer[input_port_number];
		
		op_pk_nfd_get(pkptr, "type", &tmp_type);
		op_pk_nfd_get(pkptr, "data", &tmp_data);
		
		
		// op_pk_send(pkptr, 0);
		// IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
		
		
		if(tmp_type == Flit_Type_Dest_Addr){

			DHF_buffer_time[input_port_number] = INT_MAX;
			contain_DHF[input_port_number] = NOT_CONTAIN_DHF;
			
			// combined_input_port[0] = -1;

			combined_output_port[input_port_number] = 0;
			combined_input_port[0] = input_port_number;
			
			op_pk_send(pkptr, 0);
			// OUT_PORT_table[0] = OUT_PORT_BUSY;
			inport_flit_buffer[input_port_number] = NULL;
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^--------------------------@SWIRE  send DHF  at Node%d from Port:%d  to  port:%d \n", 
				This_Node_Number, input_port_number, 0);
			}
		}
		
		else if(tmp_type == Flit_Type_Tail){
		
			op_pk_send(pkptr, 0);
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			inport_flit_buffer[input_port_number] = NULL;
		
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			printf("?????????????????-----Node %d  prepare next DHF #intrpt_port:%d\n", This_Node_Number, 0);
			}
			// now find the next head flit in the buffers
			min_DHF_time = INT_MAX;
			waiting_port = -1;
			

			inport_flit_buffer[input_port_number] = NULL;
			combined_input_port[0] = -1;
			combined_output_port[input_port_number] = -1;
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_READY;
			
			
			for (i = 1; i <= Max_Deg; i++) {
				if(contain_DHF[i] == CONTAIN_DHF ){
				
					pkptr = inport_flit_buffer[i];
					op_pk_nfd_get(pkptr, "type", &tmp_type);
					op_pk_nfd_get(pkptr, "data", &tmp_data);
					
					waiting_port_forward_port_number = Routing_Table[i][tmp_data];	
					
					if(waiting_port_forward_port_number == 0 && tmp_type == Flit_Type_Dest_Addr && min_DHF_time > DHF_buffer_time[i]){
						min_DHF_time =  DHF_buffer_time[i];	
						waiting_port = i;
					}

				}
			}
			
			if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
			printf("????????????????????  waiting_port  %d\n", waiting_port);
			
			
			for (i = 0; i <= Max_Deg; i++) {
			printf("contain_DHF: %d  <---->  %d  time:%d  OUT_PORT_table: %d \n", i, contain_DHF[i], DHF_buffer_time[i], OUT_PORT_table[i]);
			}
			}
			
			if (waiting_port != -1) {
				
				printf("/////////// waiting_port:%d DHF_buffer_time:%d  type:%d data:%d  intrpt_port:%d\n", waiting_port, DHF_buffer_time[waiting_port], tmp_type, tmp_data, 0);
				
				// IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_READY;
				// DHF_buffer_time[input_port_number] = INT_MAX;
				// contain_DHF[input_port_number] = NOT_CONTAIN_DHF;
				
				
				// contain_DHF[waiting_port] = NOT_CONTAIN_DHF;
				// DHF_buffer_time[waiting_port] = INT_MAX;
				
				combined_output_port[waiting_port] = 0;	
				combined_input_port[0] = waiting_port;
				
				IN_PORT_table[waiting_port] = IN_PORT_FLIT_ARRIVED;
				// OUT_PORT_table[0] = OUT_PORT_BUSY;
				
				if (op_prg_odb_ltrace_active ("traffic") == OPC_TRUE){
				printf("?????????????????? Node%d change input port from %d to %d\n", This_Node_Number, input_port_number, waiting_port);
				}
			}
			
		}
		
		else{
			op_pk_send(pkptr, 0);
			inport_flit_buffer[input_port_number] = NULL;
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
		}
		
		op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, Neighbor_PORT_NODE_proc_Objid_map[input_port_number]);
	}
	
	FOUT;
}
	
//for debug usage
void router_handle_time_out(void){
	int intrpt_code;
	
	int timer;
	int input_port;
	int forward_port;
	int tmp_type;
	int tmp_data;
	int type;
	int data;
	Packet * pkptr;
	
	FIN(router_handle_time_out());
	
	intrpt_code = op_intrpt_code();
	
	forward_port = intrpt_code & 15;
	input_port = (intrpt_code >> 4) & 15;
	type = (intrpt_code >> 8) & 15;
	data = (intrpt_code >> 12) & 63;
	timer = (intrpt_code >> 20) & 63;
	
	if (op_prg_odb_ltrace_active ("SI") == OPC_TRUE){
	printf(" flit_timer_recorder[%d] = %d timer:%d\n", input_port, flit_timer_recorder[input_port], timer);
	}
	
	if(IN_PORT_table[input_port] == IN_PORT_FLIT_ARRIVED && flit_timer_recorder[input_port] == timer){
	// if(TRUE){	
		pkptr = inport_flit_buffer[input_port];
		op_pk_nfd_get(pkptr, "type", &tmp_type);
		op_pk_nfd_get(pkptr, "data", &tmp_data);
		
		if(tmp_type == type && tmp_data == data){

			printf("Time OUT! Interrupt Time:%8f Node:%d  type:%d  data:%d   input_port:%d  forward_port:%d\n", 
				op_sim_time() - TIME_OUT_TIME, This_Node_Number, type, data, input_port, forward_port);
	
			// op_sim_end("Simulation is stopped","","","");
		}
	}
	
	FOUT;
}

// op_intrpt_schedule_self (op_sim_time () +  TIME_OUT_TIME, (tmp_data<<16) + (tmp_type<<8) + (input_port_number<<4) + forward_port_number);

















/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void Yu_wh_router_proc (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_Yu_wh_router_proc_init (int * init_block_ptr);
	void _op_Yu_wh_router_proc_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_Yu_wh_router_proc_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_Yu_wh_router_proc_alloc (VosT_Obtype, int);
	void _op_Yu_wh_router_proc_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
Yu_wh_router_proc (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (Yu_wh_router_proc ());

		{
		/* Temporary Variables */
		
		/* End of Temporary Variables */


		FSM_ENTER ("Yu_wh_router_proc")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (Init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "Init", "Yu_wh_router_proc [Init enter execs]")
				FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Init enter execs]", state0_enter_exec)
				{
				
				PGQ_RT_ACK = op_stat_reg ("ACK_RT_PGQ", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
				initialize_router();
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (Init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "Init", "Yu_wh_router_proc [Init exit execs]")


			/** state (Init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Init", "Identify", "tr_4", "Yu_wh_router_proc [Init -> Identify : default / ]")
				/*---------------------------------------------------------*/



			/** state (Identify) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "Identify", state1_enter_exec, "Yu_wh_router_proc [Identify enter execs]")
				FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Identify enter execs]", state1_enter_exec)
				{
				// printf("ENTER IDentify!\n");
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"Yu_wh_router_proc")


			/** state (Identify) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "Identify", "Yu_wh_router_proc [Identify exit execs]")


			/** state (Identify) transition processing **/
			FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Identify trans conditions]", state1_trans_conds)
			FSM_INIT_COND (SA_FLIT)
			FSM_TEST_COND (ID_DONE)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("Identify")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, ID_STREAM;, "SA_FLIT", "ID_STREAM", "Identify", "Identify", "tr_5", "Yu_wh_router_proc [Identify -> Identify : SA_FLIT / ID_STREAM]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, TEST_ID_DONE;, "ID_DONE", "TEST_ID_DONE", "Identify", "Listening", "tr_8", "Yu_wh_router_proc [Identify -> Listening : ID_DONE / TEST_ID_DONE]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, ;, "default", "", "Identify", "Identify", "tr_7", "Yu_wh_router_proc [Identify -> Identify : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Listening) enter executives **/
			FSM_STATE_ENTER_UNFORCED (2, "Listening", state2_enter_exec, "Yu_wh_router_proc [Listening enter execs]")
				FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Listening enter execs]", state2_enter_exec)
				{
				// printf("ENTER Listening!\n");
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (5,"Yu_wh_router_proc")


			/** state (Listening) exit executives **/
			FSM_STATE_EXIT_UNFORCED (2, "Listening", "Yu_wh_router_proc [Listening exit execs]")


			/** state (Listening) transition processing **/
			FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Listening trans conditions]", state2_trans_conds)
			FSM_INIT_COND (FLIT_ARRIVAL)
			FSM_TEST_COND (PSQUEUE_READY)
			FSM_TEST_COND (TIME_OUT)
			FSM_TEST_COND (ACK)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("Listening")
			FSM_PROFILE_SECTION_OUT (state2_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, HANDLE_FLIT;, "FLIT_ARRIVAL", "HANDLE_FLIT", "Listening", "Listening", "tr_10", "Yu_wh_router_proc [Listening -> Listening : FLIT_ARRIVAL / HANDLE_FLIT]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, HANDLE_SWIRE;, "PSQUEUE_READY", "HANDLE_SWIRE", "Listening", "Listening", "tr_12", "Yu_wh_router_proc [Listening -> Listening : PSQUEUE_READY / HANDLE_SWIRE]")
				FSM_CASE_TRANSIT (2, 2, state2_enter_exec, HANDLE_TIMER;, "TIME_OUT", "HANDLE_TIMER", "Listening", "Listening", "tr_13", "Yu_wh_router_proc [Listening -> Listening : TIME_OUT / HANDLE_TIMER]")
				FSM_CASE_TRANSIT (3, 2, state2_enter_exec, HANDLE_ACK;, "ACK", "HANDLE_ACK", "Listening", "Listening", "tr_14", "Yu_wh_router_proc [Listening -> Listening : ACK / HANDLE_ACK]")
				FSM_CASE_TRANSIT (4, 2, state2_enter_exec, ;, "default", "", "Listening", "Listening", "tr_9", "Yu_wh_router_proc [Listening -> Listening : default / ]")
				}
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"Yu_wh_router_proc")
		}
	}




void
_op_Yu_wh_router_proc_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_Yu_wh_router_proc_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_Yu_wh_router_proc_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_Yu_wh_router_proc_svar function. */
#undef PGQ_RT_ACK
#undef inport_flit_buffer
#undef Routing_Table
#undef Neighbor_PORT_NODE_map
#undef combined_output_port
#undef combined_input_port
#undef Total_Node_Num
#undef This_Node_Number
#undef Max_Deg
#undef head_flit_counter
#undef DHF_buffer_time
#undef OUT_PORT_table
#undef contain_DHF
#undef IN_PORT_table
#undef stat_counter
#undef Neighbor_PORT_NODE_proc_Objid_map
#undef flit_timer
#undef flit_timer_recorder

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_Yu_wh_router_proc_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_Yu_wh_router_proc_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (Yu_wh_router_proc)",
		sizeof (Yu_wh_router_proc_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_Yu_wh_router_proc_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	Yu_wh_router_proc_state * ptr;
	FIN_MT (_op_Yu_wh_router_proc_alloc (obtype))

	ptr = (Yu_wh_router_proc_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "Yu_wh_router_proc [Init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_Yu_wh_router_proc_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	Yu_wh_router_proc_state		*prs_ptr;

	FIN_MT (_op_Yu_wh_router_proc_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (Yu_wh_router_proc_state *)gen_ptr;

	if (strcmp ("PGQ_RT_ACK" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->PGQ_RT_ACK);
		FOUT
		}
	if (strcmp ("inport_flit_buffer" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->inport_flit_buffer);
		FOUT
		}
	if (strcmp ("Routing_Table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Routing_Table);
		FOUT
		}
	if (strcmp ("Neighbor_PORT_NODE_map" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Neighbor_PORT_NODE_map);
		FOUT
		}
	if (strcmp ("combined_output_port" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->combined_output_port);
		FOUT
		}
	if (strcmp ("combined_input_port" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->combined_input_port);
		FOUT
		}
	if (strcmp ("Total_Node_Num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Total_Node_Num);
		FOUT
		}
	if (strcmp ("This_Node_Number" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->This_Node_Number);
		FOUT
		}
	if (strcmp ("Max_Deg" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Max_Deg);
		FOUT
		}
	if (strcmp ("head_flit_counter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->head_flit_counter);
		FOUT
		}
	if (strcmp ("DHF_buffer_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DHF_buffer_time);
		FOUT
		}
	if (strcmp ("OUT_PORT_table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->OUT_PORT_table);
		FOUT
		}
	if (strcmp ("contain_DHF" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->contain_DHF);
		FOUT
		}
	if (strcmp ("IN_PORT_table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->IN_PORT_table);
		FOUT
		}
	if (strcmp ("stat_counter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->stat_counter);
		FOUT
		}
	if (strcmp ("Neighbor_PORT_NODE_proc_Objid_map" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Neighbor_PORT_NODE_proc_Objid_map);
		FOUT
		}
	if (strcmp ("flit_timer" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->flit_timer);
		FOUT
		}
	if (strcmp ("flit_timer_recorder" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->flit_timer_recorder);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

