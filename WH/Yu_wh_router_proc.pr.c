/* Process model C form file: Yu_wh_router_proc.pr.c */
/* Portions of this file copyright 1986-2011 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from Yu_wh_router_proc.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char Yu_wh_router_proc_pr_c [] = "MIL_3_Tfile_Hdr_ 171A 30A modeler 7 55202389 55202389 1 ECE-PHO309-01 chenyua 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 2b1a 1                                                                                                                                                                                                                                                                                                                                                                                                    ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

// include files
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <direct.h>

/*
define the interrupt codes here
*/
#define SA_FLIT_INTRPT_CODE 1000
#define ID_DONE_INTRPT_CODE 1001

// define FLIT_ARRIVAL, stream interrupt within the node
#define FLIT_ARRIVAL (op_intrpt_type () == OPC_INTRPT_STRM)

// check the adjacent nodes
#define SA_FLIT (op_intrpt_type () == OPC_INTRPT_STRM)

// ACK remote intrpt from adjacent node
#define ACK (op_intrpt_type () == OPC_INTRPT_REMOTE)

// PSQUEUE_READY signal
#define PSQUEUE_READY (op_intrpt_type () == OPC_INTRPT_STAT)

// define the time out handler
#define TIME_OUT (op_intrpt_type () == OPC_INTRPT_SELF)

// define the time out handler
#define ID_DONE (op_intrpt_type () == OPC_INTRPT_SELF)

// define flit type here
#define Flit_Type_Data_Flit 0
#define Flit_Type_Dest_Addr 1
#define Flit_Type_Src_Addr 2
#define Flit_Type_Worm_Length 6
#define Flit_Type_Tail 7

// read the node specified routing table here
#define ID_STREAM get_id_stream();

// flit handler when a flit is arriving
#define HANDLE_FLIT flit_handler();

// ACK handler
#define HANDLE_ACK ACK_handler();

// handler swire when PSQueue is ready
#define HANDLE_SWIRE SWIRE_handler();

// 
#define HANDLE_TIMER router_handle_time_out();

//
#define TEST_ID_DONE test_ID_DONE();

// out PORT is Busy or not
#define OUT_PORT_BUSY 1
#define OUT_PORT_FREE 0

// IN_PORT_table
#define IN_PORT_FLIT_ARRIVED 3
#define IN_PORT_NEXT_NODE_BUSY 0
#define IN_PORT_NEXT_NODE_READY 1

// IS_SINK_READY
#define SINK_READY 1
#define SINK_BUSY 0

// contain_DHF
#define CONTAIN_DHF 1
#define NOT_CONTAIN_DHF 0







/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Stathandle	             		PGQ_RT_ACK                                      ;
	Packet **	              		inport_flit_buffer                              ;
	int **	                 		Routing_Table                                   ;
	int *	                  		Neighbor_PORT_NODE_map                          ;
	int *	                  		combined_output_port                            ;
	int *	                  		combined_input_port                             ;
	int	                    		Total_Node_Num                                  ;
	int	                    		This_Node_Number                                ;
	int	                    		port_number                                     ;
	int	                    		Out_Node_Number                                 ;
	int	                    		My_Total_Node_Num                               ;
	int	                    		Max_Deg                                         ;
	int	                    		In_Node_Number                                  ;
	int	                    		flit_counter                                    ;
	int *	                  		DHF_buffer_time                                 ;
	int *	                  		OUT_PORT_table                                  ;
	int	                    		IS_SINK_READY                                   ;
	int *	                  		contain_DHF                                     ;
	int *	                  		IN_PORT_table                                   ;
	} Yu_wh_router_proc_state;

#define PGQ_RT_ACK              		op_sv_ptr->PGQ_RT_ACK
#define inport_flit_buffer      		op_sv_ptr->inport_flit_buffer
#define Routing_Table           		op_sv_ptr->Routing_Table
#define Neighbor_PORT_NODE_map  		op_sv_ptr->Neighbor_PORT_NODE_map
#define combined_output_port    		op_sv_ptr->combined_output_port
#define combined_input_port     		op_sv_ptr->combined_input_port
#define Total_Node_Num          		op_sv_ptr->Total_Node_Num
#define This_Node_Number        		op_sv_ptr->This_Node_Number
#define port_number             		op_sv_ptr->port_number
#define Out_Node_Number         		op_sv_ptr->Out_Node_Number
#define My_Total_Node_Num       		op_sv_ptr->My_Total_Node_Num
#define Max_Deg                 		op_sv_ptr->Max_Deg
#define In_Node_Number          		op_sv_ptr->In_Node_Number
#define flit_counter            		op_sv_ptr->flit_counter
#define DHF_buffer_time         		op_sv_ptr->DHF_buffer_time
#define OUT_PORT_table          		op_sv_ptr->OUT_PORT_table
#define IS_SINK_READY           		op_sv_ptr->IS_SINK_READY
#define contain_DHF             		op_sv_ptr->contain_DHF
#define IN_PORT_table           		op_sv_ptr->IN_PORT_table

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	Yu_wh_router_proc_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((Yu_wh_router_proc_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

Packet * r_generate_flit(int type, int data){
	Packet * pkptr;
	
	FIN(generate_flit());
	
	pkptr = op_pk_create_fmt("Yu_wh_pkformat");
	op_pk_nfd_set(pkptr, "type", type);
	op_pk_nfd_set(pkptr, "data", data);
	
	FRET(pkptr);
}

void test_ID_DONE(void){
	int i;
	
	FIN(test_ID_DONE());
	
	if (op_prg_odb_ltrace_active ("IDDONE") == OPC_TRUE){
		printf("ID_DONE@%d\n", This_Node_Number);
		for (i = 0; i <= Max_Deg; i++) {
			printf("Neighbor_PORT_NODE_map: %d  <---->  %d\n", i, Neighbor_PORT_NODE_map[i]);
		}
		
		for (i = 0; i <= Max_Deg; i++) {
			printf("OUT_PORT_table: %d  <---->  %d\n", i, OUT_PORT_table[i]);
		}
		
	}
	FOUT;
}

void load_ARnode_routing_table(void) {

	Objid myObjid, parentObjid;
	char parentname[64];
	char RName[128];
	FILE * Rinfile;
	char lbuf[2048];
	char * nToken;

	int i;
	int row;
	int col;
	int dest_port;
	
	FIN(load_ARnode_routing_table());
	
	// get the local node number
	myObjid = op_id_self();
	parentObjid = op_topo_parent (myObjid);
	op_ima_obj_attr_get (parentObjid, "name", &parentname);
	This_Node_Number = atoi(&parentname[5]);
	
	// get the routing table file path
	sprintf(RName, "C:\\Users\\chenyua\\OPNET_Project\\WH\\ARnode_%d.txt", This_Node_Number);
	if (!(Rinfile = fopen(RName, "r"))) {
		printf("initialize_gen: could not find file");
		exit(-2);
	}
	
	fgets(lbuf, 2048, Rinfile);
	nToken = strtok(lbuf, " \t\n");
	Total_Node_Num = atoi(nToken);
	nToken = strtok(NULL, " \t\n");
	Max_Deg = atoi(nToken);
	
	// printf("Node@%d  Total_Node_Num: %d  Max_Deg: %d\n",This_Node_Number, Total_Node_Num, Max_Deg);
	
	// the reason for adding one here is that the port includes the PSQueue port, i.e. port #0	
	Routing_Table = (int **)op_prg_mem_alloc( (Max_Deg + 1)* sizeof(int *));
	for (i = 0; i <= Max_Deg; i++) {
		Routing_Table[i] = (int *)op_prg_mem_alloc(Total_Node_Num * sizeof(int));
	}
	
	row = 0;
	while(fgets(lbuf, 2048, Rinfile)){
		// printf("lind: %s", lbuf);
		nToken = strtok(lbuf, " ] [ ");
		
		for (col = 0; col < Total_Node_Num; col++) {
			
			dest_port = atoi(nToken);
			Routing_Table[row][col] = dest_port;
			
			if (op_prg_odb_ltrace_active ("RTAR") == OPC_TRUE){
				printf("%3d", Routing_Table[row][col]);
				if(col == Total_Node_Num - 1){
					printf("\nrow:%d  col:%d\n", row, col);
				}
			}
			nToken = strtok(NULL, " ] [ ");	
		}
		row++;
	}
	FOUT;
}

void load_Rnode_routing_table(void) {

	Objid myObjid, parentObjid;
	char parentname[64];
	char RName[128];
	FILE * Rinfile;
	char lbuf[2048];
	char * nToken;

	int i;
	int row;
	int col;
	int dest_port;
	
	FIN(load_ARnode_routing_table());
	
	// get the local node number
	myObjid = op_id_self();
	parentObjid = op_topo_parent (myObjid);
	op_ima_obj_attr_get (parentObjid, "name", &parentname);
	This_Node_Number = atoi(&parentname[5]);
	
	// get the routing table file path
	sprintf(RName, "C:\\Users\\chenyua\\OPNET_Project\\WH_G4x4\\Rnode_%d.txt", This_Node_Number);
	if (!(Rinfile = fopen(RName, "r"))) {
		printf("initialize_gen: could not find file");
		exit(-2);
	}
	
	fgets(lbuf, 2048, Rinfile);
	nToken = strtok(lbuf, " \t\n");
	Total_Node_Num = atoi(nToken);
	nToken = strtok(NULL, " \t\n");
	Max_Deg = atoi(nToken);
	
	// printf("Node@%d @router Total_Node_Num: %d  Max_Deg: %d\n",This_Node_Number, Total_Node_Num, Max_Deg);
	
	// the reason for adding one here is that the port includes the PSQueue port, i.e. port #0	
	Routing_Table = (int **)op_prg_mem_alloc( (Max_Deg + 1)* sizeof(int * ));
	for (i = 0; i <= Max_Deg; i++) {
		Routing_Table[i] = (int *)op_prg_mem_alloc(Total_Node_Num * sizeof(int));
	}
	
	row = 0;
	while(fgets(lbuf, 2048, Rinfile)){
		// printf("lind: %s", lbuf);
		nToken = strtok(lbuf, " ");
		
		for (col = 0; col < Total_Node_Num; col++) {
			
			dest_port = atoi(nToken);
			Routing_Table[row][col] = dest_port;
			
			if (op_prg_odb_ltrace_active ("RTR") == OPC_TRUE){
				printf("%3d", Routing_Table[row][col]);
				if(col == Total_Node_Num - 1){
					printf("\nrow:%d  col:%d\n", row, col);
				}
			}
			nToken = strtok(NULL, " ");	
		}
		row++;
	}
	FOUT;
}

void send_remote_intrpt_to_adjacent_node(void){
	
	Packet * pkptr;
	int strm_pt;
	
	FIN(send_remote_intrpt_to_adjacent_node());
	
	for (strm_pt = 2; strm_pt <= Max_Deg + 1; strm_pt++) {
	//for (strm_pt = 2; strm_pt <= 2; strm_pt++) {
		pkptr = r_generate_flit(Flit_Type_Src_Addr, This_Node_Number);				
		op_pk_send(pkptr, strm_pt);
	}
	
	FOUT;
}

void initialize_router(void){
	
	int i;
	
	FIN(initialize_router());

	flit_counter = 0;
	// IS_SINK_READY = SINK_READY;
	
		
	// call the routing table initializer here
	// if(This_Node_Number == 0)
	// load_ARnode_routing_table();
	load_Rnode_routing_table();
	
	// status of input output ports, or associate input port structures
	inport_flit_buffer = (Packet **)op_prg_mem_alloc((Max_Deg + 1)* sizeof(Packet *));
//	for (i = 1; i <= Max_Deg; i++) {
//		inport_flit_buffer[i] = (Packet *)op_prg_mem_alloc(sizeof(Packet));
//	}
	
	
	DHF_buffer_time = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));
	
	// output ports and associate output port structures
	OUT_PORT_table = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));
	IN_PORT_table = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));
	
	Neighbor_PORT_NODE_map = (int *)op_prg_mem_alloc((Max_Deg + 1) * sizeof(int));
	combined_input_port = (int *)op_prg_mem_alloc((Max_Deg + 1) * sizeof(int));
	combined_output_port = (int *)op_prg_mem_alloc((Max_Deg + 1) * sizeof(int));
	contain_DHF = (int *)op_prg_mem_alloc((Max_Deg + 1)* sizeof(int));
		

	
	// initialize the variables
	for (i = 0; i <= Max_Deg; i++) {
		OUT_PORT_table[i] = OUT_PORT_FREE;
		IN_PORT_table[i] = IN_PORT_NEXT_NODE_READY;
		
		DHF_buffer_time[i] = 0;
		combined_input_port[i] = -1;
		combined_output_port[i] = -1;
		inport_flit_buffer[i] = NULL;
		contain_DHF[i] = NOT_CONTAIN_DHF;
		Neighbor_PORT_NODE_map[i] = -1;
	}
	
	Neighbor_PORT_NODE_map[0] = This_Node_Number;
//	for (i = 1; i <= Max_Deg; i++) {
//		Neighbor_PORT_NODE_map[i] = -1;
//	}
	
	
//	for (i = 0; i <= Max_Deg; i++) {
//		printf("++++++++++ Node: %d Neighbor_PORT_NODE_map  %d  --  %d\n", This_Node_Number, i, Neighbor_PORT_NODE_map[i]);
//	}
//	printf("\n");
		
	// send the source head flit to adjacent nodes, they will get the connection status
	send_remote_intrpt_to_adjacent_node();

	FOUT;
}

// get node attribution in Identify state
// get the neighbors ID
void get_id_stream(void) {

	Packet * pkptr;
	int type;
	int data;
	int strm_port_number;
	
	FIN(get_id_stream());
	
	strm_port_number = op_intrpt_strm ();
	
	pkptr = op_pk_get (strm_port_number);
	op_pk_nfd_get(pkptr, "type", &type);
	op_pk_nfd_get(pkptr, "data", &data);
	

	
	if (op_prg_odb_ltrace_active ("SA") == OPC_TRUE && This_Node_Number == 1){
		printf("R_Node:%d @router strm@%d: type:%d data:%d\n", This_Node_Number, strm_port_number, type, data);
		printf("node@%d intrpt node:%d\n", This_Node_Number, data);
	}
	
	// the real #port = #stream - 1
	Neighbor_PORT_NODE_map[strm_port_number - 1] = data;

	// schedule a self interrupt to move to Listening status
	op_intrpt_schedule_self (op_sim_time (), 0);

	FOUT;
}

// functions for Listerning
void flit_handler(void){
	Packet * pkptr;

	int tmp_type;
	int tmp_data;
	int forward_strm_number;
	int forward_port_number;
	int input_strm_number;
	int input_port_number;
	int waiting_port;
	int i;
	int waiting_port_forward_port_number;
	
	int max_DHF_time = 0;

	int coming_node_number;
	char coming_node_name[32];
	Objid neighbor_node_objid, neighbor_proc_objid;
	Objid next_node_objid, next_proc_objid;
	
	FIN(flit_handler());

	flit_counter++;
	
	input_strm_number = op_intrpt_strm();
	input_port_number = (input_strm_number == 0 ? 0 : input_strm_number - 1);
	
	pkptr = op_pk_get(input_strm_number);
	op_pk_nfd_get(pkptr, "type", &tmp_type);
	op_pk_nfd_get(pkptr, "data", &tmp_data);
	
	if (op_prg_odb_ltrace_active ("LS") == OPC_TRUE){
		printf("node:%d @flit_handler #input_port_number#%d  status:%d type:%d data:%d\n", 
			This_Node_Number, input_port_number, IN_PORT_table[input_port_number], tmp_type, tmp_data);
	}
	

	// call other procedures that handle individual flit types
	if(tmp_type == Flit_Type_Dest_Addr) {

		forward_port_number = Routing_Table[input_port_number][tmp_data];		
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);

		// identify whether the port is busy or not, if the output port is free, then send the head flit 
		// to the port and set the port is busy, it will get free when the tail flit been passed
	
		// if(OUT_PORT_table[forward_port_number] == OUT_PORT_FREE){
		if(OUT_PORT_table[forward_port_number] == OUT_PORT_FREE  && IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
			
			op_pk_send(pkptr, forward_strm_number);	
			
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			OUT_PORT_table[forward_port_number] = OUT_PORT_BUSY;
			combined_output_port[input_port_number] = forward_port_number;
			combined_input_port[forward_port_number] = input_port_number;	
			
			if(input_strm_number == 0){
				flit_counter++;
				op_stat_write (PGQ_RT_ACK, flit_counter);
			}else{
				coming_node_number = Neighbor_PORT_NODE_map[input_port_number];
				sprintf(coming_node_name, "node_%d", coming_node_number);
				
				neighbor_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, coming_node_name);
				neighbor_proc_objid = op_id_from_name (neighbor_node_objid, OPC_OBJTYPE_PROC, "router");
				op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, neighbor_proc_objid);
			}
			
	
		}
		// else if it's busy, keep the header flit in a register
		else{
			printf("++++++++++++++++++++Node:%d Port:%d is busy  from port:%d   OUT_PORT_table[]%d  IN_PORT_table[]%d\n", 
				This_Node_Number, forward_port_number, input_port_number, OUT_PORT_table[forward_port_number], IN_PORT_table[input_port_number]);
			
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
			DHF_buffer_time[input_port_number] = flit_counter;
			contain_DHF[input_port_number] = CONTAIN_DHF;
			
			
			for (i = 0; i <= Max_Deg; i++) {
				printf("Node:%d  contain_DHF[%d]=%d\n",This_Node_Number, i, contain_DHF[i]);
			}
			
			for (i = 0; i <= Max_Deg; i++) {
				printf("Node:%d  OUT_PORT_table[%d]=%d\n",This_Node_Number, i, OUT_PORT_table[i]);
			}
			
		}
	// else if it's not busy, then the input port it came from is associated with the 
	// output port and binding takes place
	}else if(tmp_type == Flit_Type_Src_Addr) {

		forward_port_number = combined_output_port[input_port_number];
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);
	
		// if(forward_port_number == 0 && IS_SINK_READY == SINK_READY){
		if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
			// op_pk_send(pkptr, 0);
			op_pk_send(pkptr, forward_strm_number);
			// IS_SINK_READY = SINK_BUSY;
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			
			coming_node_number = Neighbor_PORT_NODE_map[input_port_number];
			sprintf(coming_node_name, "node_%d", coming_node_number);
			neighbor_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, coming_node_name);
			neighbor_proc_objid = op_id_from_name (neighbor_node_objid, OPC_OBJTYPE_PROC, "router");
			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, neighbor_proc_objid);
			
		}else{
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
		}
		

	}else if(tmp_type == Flit_Type_Worm_Length) {

		forward_port_number = combined_output_port[input_port_number];
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);
	
		// if(forward_port_number == 0 && IS_SINK_READY == SINK_READY){
		if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
			// op_pk_send(pkptr, 0);
			op_pk_send(pkptr, forward_strm_number);
			// IS_SINK_READY = SINK_BUSY;
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			
			coming_node_number = Neighbor_PORT_NODE_map[input_port_number];
			sprintf(coming_node_name, "node_%d", coming_node_number);
			neighbor_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, coming_node_name);
			neighbor_proc_objid = op_id_from_name (neighbor_node_objid, OPC_OBJTYPE_PROC, "router");
			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, neighbor_proc_objid);
			
		}else{
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
		}
		
	}else if(tmp_type == Flit_Type_Data_Flit) {	
		
		forward_port_number = combined_output_port[input_port_number];
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);
	
		// if(forward_port_number == 0 && IS_SINK_READY == SINK_READY){
		if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
			// op_pk_send(pkptr, 0);
			op_pk_send(pkptr, forward_strm_number);
			// IS_SINK_READY = SINK_BUSY;
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			
			coming_node_number = Neighbor_PORT_NODE_map[input_port_number];
			sprintf(coming_node_name, "node_%d", coming_node_number);
			neighbor_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, coming_node_name);
			neighbor_proc_objid = op_id_from_name (neighbor_node_objid, OPC_OBJTYPE_PROC, "router");
			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, neighbor_proc_objid);
			
		}else{
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
		}
	}
	// tail flit
	else if(tmp_type == Flit_Type_Tail) {	
	
		forward_port_number = combined_output_port[input_port_number];
		forward_strm_number = (forward_port_number == 0 ? 0 : forward_port_number + 1);


		// if(forward_port_number == 0 && IS_SINK_READY == SINK_READY){
		if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_READY){
		
			op_pk_send(pkptr, forward_strm_number);
			
			IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
			OUT_PORT_table[forward_port_number] = OUT_PORT_FREE;
			combined_output_port[input_port_number] = -1;	
			// combined_input_port[forward_port_number] = -1;
			inport_flit_buffer[input_port_number] = NULL;
			
			printf("*****************Node:%d, port: 0\n", This_Node_Number);
			// now find the next head flit in the buffers
			max_DHF_time = -1.0;
			waiting_port = -1;
			for (i = 0; i <= Max_Deg; i++) {
				if(contain_DHF[i] == CONTAIN_DHF && max_DHF_time < DHF_buffer_time[i]){
				
					pkptr = inport_flit_buffer[i];
					op_pk_nfd_get(pkptr, "type", &tmp_type);
					op_pk_nfd_get(pkptr, "data", &tmp_data);
					max_DHF_time =  DHF_buffer_time[i];
					waiting_port_forward_port_number = Routing_Table[i][tmp_data];	
					
					if(waiting_port_forward_port_number == forward_port_number && tmp_type == Flit_Type_Dest_Addr){
						waiting_port = i;
					}
				}
			}
		
			printf("*****************  waiting_port  %d\n", waiting_port);
			
			for (i = 0; i <= Max_Deg; i++) {
				printf("contain_DHF: %d  <---->  %d  time:%d  OUT_PORT_table: %d \n", i, contain_DHF[i], DHF_buffer_time[i], OUT_PORT_table[i]);
			}
			
			if (waiting_port != -1) {	
				
				printf("*********** waiting_port:%d type:%d data:%d  DHF_buffer_time:%d  forward_port_number:%d\n",
					waiting_port, tmp_type, tmp_data, max_DHF_time, forward_port_number);	
				
				IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_READY;
				contain_DHF[input_port_number] = NOT_CONTAIN_DHF;
				DHF_buffer_time[input_port_number] = 0;
				
				
				IN_PORT_table[waiting_port] = IN_PORT_FLIT_ARRIVED;
				contain_DHF[waiting_port] = NOT_CONTAIN_DHF;
				DHF_buffer_time[waiting_port] = 0;
				OUT_PORT_table[forward_port_number] = OUT_PORT_BUSY;
				combined_output_port[waiting_port] = forward_port_number;	
				combined_input_port[forward_port_number] = waiting_port;
				inport_flit_buffer[waiting_port] = pkptr;

			}
				
			if(input_port_number == 0){
				flit_counter++;
				op_stat_write (PGQ_RT_ACK, flit_counter);
			}
			
			else{
				coming_node_number = Neighbor_PORT_NODE_map[input_port_number];
				sprintf(coming_node_name, "node_%d", coming_node_number);
						
				next_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, coming_node_name);
				next_proc_objid = op_id_from_name (next_node_objid, OPC_OBJTYPE_PROC, "router");
				op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, next_proc_objid);
			}

			
		}else if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_BUSY){
			inport_flit_buffer[input_port_number] = pkptr;
			IN_PORT_table[input_port_number] = IN_PORT_FLIT_ARRIVED;
		}
	}else{
		printf("ERROR:pkptr  node:%d @flit_handler #input_port_number#%d  type:%d data:%d\n", This_Node_Number, input_port_number, tmp_type, tmp_data);
	}
	FOUT;
}

void ACK_handler(void) {

	int src_intrpt_node_number;
	int intrpt_port;
	int send_strm;
	int my_combined_input_port;
	int next_node_number;
	int tmp_type;
	int tmp_data;
	char next_node_name[64];
	int waiting_port_forward_port_number;
	
	Packet * pkptr;
	Objid next_node_objid, next_proc_objid;
	
	int max_DHF_time;
	int waiting_port;
	int i;
//	int forward_strm_number;
//	int forward_port_number;
//	int coming_node_number;
//  	char coming_node_name[32];
	
	FIN(ACK_handler());
	
	src_intrpt_node_number = op_intrpt_code();
	
	if (op_prg_odb_ltrace_active ("ACK") == OPC_TRUE){
		printf("ACK  Node:%d receive from Node:%d \n", This_Node_Number, src_intrpt_node_number);
	}
	
	for (intrpt_port = 0; intrpt_port <= Max_Deg; intrpt_port++) {
		if(Neighbor_PORT_NODE_map[intrpt_port] == src_intrpt_node_number) {
			break;
		}
	}
	
	send_strm = (intrpt_port == 0 ? 0 : intrpt_port + 1);
	my_combined_input_port = combined_input_port[intrpt_port];
	
	if(my_combined_input_port == -1){
		printf("=========================================my_combined_input_port == -1 \n");
		
		FOUT;
	}
	
	if(IN_PORT_table[my_combined_input_port] == IN_PORT_NEXT_NODE_BUSY){
		IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_READY;
		printf("????????????????????BUSY --> READY intrpt_port %d  my_combined_input_port %d input_port_status:%d\n", 
			intrpt_port, my_combined_input_port, IN_PORT_table[my_combined_input_port]);
	} 
	
	else if(IN_PORT_table[my_combined_input_port] == IN_PORT_FLIT_ARRIVED){
		printf("@@@@@@@@@@@@@@@@@@@@ intrpt_port %d  my_combined_input_port %d input_port_status:%d\n", 
			intrpt_port, my_combined_input_port, IN_PORT_table[my_combined_input_port]);

		pkptr = inport_flit_buffer[my_combined_input_port];
		
		op_pk_nfd_get(pkptr, "type", &tmp_type);
		op_pk_nfd_get(pkptr, "data", &tmp_data);
		op_pk_send(pkptr, send_strm);
		IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_BUSY;
		
		
		if(tmp_type == Flit_Type_Dest_Addr){
			OUT_PORT_table[intrpt_port] = OUT_PORT_BUSY;
			DHF_buffer_time[my_combined_input_port] = 0;
			contain_DHF[my_combined_input_port] = NOT_CONTAIN_DHF;
			printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ send DHF  at Node%d \n", This_Node_Number);
		}

		else if(tmp_type == Flit_Type_Tail){

			printf("////-----Node %d  prepare next DHF #intrpt_port:%d\n", This_Node_Number, intrpt_port);
			// now find the next head flit in the buffers
			max_DHF_time = -1.0;
			waiting_port = -1;
			
			OUT_PORT_table[intrpt_port] = OUT_PORT_FREE;
			inport_flit_buffer[my_combined_input_port] = NULL;
			// combined_input_port[intrpt_port] = -1;
			combined_output_port[my_combined_input_port] = -1;
			IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_BUSY;
			
			for (i = 0; i <= Max_Deg; i++) {
				
				printf("contain_DHF: %d  <---->  %d  time:%d  OUT_PORT_table: %d \n", i, contain_DHF[i], DHF_buffer_time[i], OUT_PORT_table[i]);
			}
			
			for (i = 0; i <= Max_Deg; i++) {
				if(contain_DHF[i] == CONTAIN_DHF && max_DHF_time < DHF_buffer_time[i]){
				
					pkptr = inport_flit_buffer[i];
					op_pk_nfd_get(pkptr, "type", &tmp_type);
					op_pk_nfd_get(pkptr, "data", &tmp_data);
					max_DHF_time =  DHF_buffer_time[i];	
					waiting_port_forward_port_number = Routing_Table[i][tmp_data];	
					
					if(waiting_port_forward_port_number == intrpt_port && tmp_type == Flit_Type_Dest_Addr){
						waiting_port = i;
					}

				}
			}
			
			printf("////////////////////////  waiting_port  %d\n", waiting_port);
			

			
			if (waiting_port != -1) {
				
				printf("/////////// waiting_port:%d DHF_buffer_time:%d  type:%d data:%d  intrpt_port:%d\n",
				 	 waiting_port, max_DHF_time, tmp_type, tmp_data,  intrpt_port);			

				IN_PORT_table[my_combined_input_port] = IN_PORT_NEXT_NODE_READY;
				DHF_buffer_time[my_combined_input_port] = 0;
				contain_DHF[my_combined_input_port] = NOT_CONTAIN_DHF;
				
				
				IN_PORT_table[waiting_port] = IN_PORT_FLIT_ARRIVED;
				contain_DHF[waiting_port] = NOT_CONTAIN_DHF;
				combined_output_port[waiting_port] = intrpt_port;	
				combined_input_port[intrpt_port] = waiting_port;
				DHF_buffer_time[waiting_port] = 0;
				contain_DHF[waiting_port] = NOT_CONTAIN_DHF;
				OUT_PORT_table[intrpt_port] = OUT_PORT_BUSY;
				printf("////////////////////////  Node%d change input port from %d to %d\n",
					This_Node_Number, my_combined_input_port, waiting_port);

			}
			
			
		}
		
		
		if(my_combined_input_port == 0){
			flit_counter++;
			op_stat_write (PGQ_RT_ACK, flit_counter);
			
		}else{
			next_node_number = Neighbor_PORT_NODE_map[my_combined_input_port];
			sprintf(next_node_name, "node_%d", next_node_number);
			next_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, next_node_name);
			next_proc_objid = op_id_from_name (next_node_objid, OPC_OBJTYPE_PROC, "router");
			
			op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, next_proc_objid);
		}
	
	}
	
	FOUT;
}

void SWIRE_handler(void){

	int input_port_number;
	
	
	int tmp_type;
	int tmp_data;
	Packet * pkptr;

	int max_DHF_time;
	int waiting_port;
	
	int next_node_number;
	char next_node_name[32];
	int i;
	
	Objid next_node_objid, next_proc_objid;
	
	
	FIN(SWIRE_handler());
	
	input_port_number = combined_input_port[0];
	
	if(input_port_number == -1){
		printf("==================-----------------input_port_number == -1  @NOde%d\n", This_Node_Number);
		FOUT;
	}

	
	if(IN_PORT_table[input_port_number] == IN_PORT_NEXT_NODE_BUSY){
		IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_READY;
		printf("xxxxxxxxxxxxxxxx  Node:%d WIRE PORT:%d  BUSY --> READY \n", This_Node_Number, input_port_number);
	} 
	
	else if(IN_PORT_table[input_port_number] == IN_PORT_FLIT_ARRIVED){
		
		pkptr = inport_flit_buffer[input_port_number];
		
		op_pk_nfd_get(pkptr, "type", &tmp_type);
		op_pk_nfd_get(pkptr, "data", &tmp_data);
		op_pk_send(pkptr, 0);
		
		IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_BUSY;
		
		
		if(tmp_type == Flit_Type_Dest_Addr){
			OUT_PORT_table[0] = OUT_PORT_BUSY;
			DHF_buffer_time[input_port_number] = 0;
			contain_DHF[input_port_number] = NOT_CONTAIN_DHF;
			printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------------------- %d \n", This_Node_Number);
		}
		
		else if(tmp_type == Flit_Type_Tail){

			printf("?????????????????-----Node %d  prepare next DHF #intrpt_port:%d\n", This_Node_Number, 0);
			// now find the next head flit in the buffers
			max_DHF_time = -1.0;
			waiting_port = -1;
			
			OUT_PORT_table[0] = OUT_PORT_FREE;
			inport_flit_buffer[input_port_number] = NULL;
			// combined_input_port[0] = -1;
			combined_output_port[input_port_number] = -1;
			// IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_READY;
			
			
			for (i = 0; i <= Max_Deg; i++) {
				if(contain_DHF[i] == CONTAIN_DHF && max_DHF_time < DHF_buffer_time[i]){
				
					pkptr = inport_flit_buffer[i];
					op_pk_nfd_get(pkptr, "type", &tmp_type);
					op_pk_nfd_get(pkptr, "data", &tmp_data);
					max_DHF_time =  DHF_buffer_time[i];	
					
					if(tmp_data == 0 && tmp_type == Flit_Type_Dest_Addr){
						waiting_port = i;
					}

				}
			}
			
			printf("????????????????????  waiting_port  %d\n", waiting_port);
			
			for (i = 0; i <= Max_Deg; i++) {
				printf("contain_DHF: %d  <---->  %d  time:%d  OUT_PORT_table: %d \n", i, contain_DHF[i], DHF_buffer_time[i], OUT_PORT_table[i]);
			}
			
			if (waiting_port != -1) {
				
				printf("/////////// waiting_port:%d DHF_buffer_time:%d  type:%d data:%d  intrpt_port:%d\n",
				 	 waiting_port, tmp_type, tmp_data, max_DHF_time, 0);		
				IN_PORT_table[input_port_number] = IN_PORT_NEXT_NODE_READY;
				DHF_buffer_time[input_port_number] = 0;
				contain_DHF[input_port_number] = NOT_CONTAIN_DHF;
				
				
				contain_DHF[waiting_port] = NOT_CONTAIN_DHF;
				combined_output_port[waiting_port] = 0;	
				combined_input_port[0] = waiting_port;
				DHF_buffer_time[waiting_port] = 0;
				IN_PORT_table[waiting_port] = IN_PORT_FLIT_ARRIVED;
				OUT_PORT_table[0] = OUT_PORT_BUSY;
				printf("?????????????????? Node%d change input port from %d to %d\n",
					This_Node_Number, input_port_number, waiting_port);

			}
			
		}
		
		next_node_number = Neighbor_PORT_NODE_map[input_port_number];
		sprintf(next_node_name, "node_%d", next_node_number);
		next_node_objid = op_id_from_name (1, OPC_OBJTYPE_NODE_FIXED, next_node_name);
		next_proc_objid = op_id_from_name (next_node_objid, OPC_OBJTYPE_PROC, "router");			
		op_intrpt_schedule_remote(op_sim_time(), This_Node_Number, next_proc_objid);

	}
	
	FOUT;
}
	
//for debug usage
void router_handle_time_out(void){
	int intrpt_code;
	
	FIN(router_handle_time_out());
	
	intrpt_code = op_intrpt_code();

	FOUT;
}


























/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void Yu_wh_router_proc (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_Yu_wh_router_proc_init (int * init_block_ptr);
	void _op_Yu_wh_router_proc_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_Yu_wh_router_proc_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_Yu_wh_router_proc_alloc (VosT_Obtype, int);
	void _op_Yu_wh_router_proc_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
Yu_wh_router_proc (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (Yu_wh_router_proc ());

		{
		/* Temporary Variables */
		
		/* End of Temporary Variables */


		FSM_ENTER ("Yu_wh_router_proc")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (Init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "Init", "Yu_wh_router_proc [Init enter execs]")
				FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Init enter execs]", state0_enter_exec)
				{
				
				PGQ_RT_ACK = op_stat_reg ("ACK_RT_PGQ", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
				initialize_router();
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (Init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "Init", "Yu_wh_router_proc [Init exit execs]")


			/** state (Init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Init", "Identify", "tr_4", "Yu_wh_router_proc [Init -> Identify : default / ]")
				/*---------------------------------------------------------*/



			/** state (Identify) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "Identify", state1_enter_exec, "Yu_wh_router_proc [Identify enter execs]")
				FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Identify enter execs]", state1_enter_exec)
				{
				// printf("ENTER IDentify!\n");
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"Yu_wh_router_proc")


			/** state (Identify) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "Identify", "Yu_wh_router_proc [Identify exit execs]")


			/** state (Identify) transition processing **/
			FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Identify trans conditions]", state1_trans_conds)
			FSM_INIT_COND (SA_FLIT)
			FSM_TEST_COND (ID_DONE)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("Identify")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, ID_STREAM;, "SA_FLIT", "ID_STREAM", "Identify", "Identify", "tr_5", "Yu_wh_router_proc [Identify -> Identify : SA_FLIT / ID_STREAM]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, TEST_ID_DONE;, "ID_DONE", "TEST_ID_DONE", "Identify", "Listening", "tr_8", "Yu_wh_router_proc [Identify -> Listening : ID_DONE / TEST_ID_DONE]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, ;, "default", "", "Identify", "Identify", "tr_7", "Yu_wh_router_proc [Identify -> Identify : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Listening) enter executives **/
			FSM_STATE_ENTER_UNFORCED (2, "Listening", state2_enter_exec, "Yu_wh_router_proc [Listening enter execs]")
				FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Listening enter execs]", state2_enter_exec)
				{
				// printf("ENTER Listening!\n");
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (5,"Yu_wh_router_proc")


			/** state (Listening) exit executives **/
			FSM_STATE_EXIT_UNFORCED (2, "Listening", "Yu_wh_router_proc [Listening exit execs]")


			/** state (Listening) transition processing **/
			FSM_PROFILE_SECTION_IN ("Yu_wh_router_proc [Listening trans conditions]", state2_trans_conds)
			FSM_INIT_COND (FLIT_ARRIVAL)
			FSM_TEST_COND (PSQUEUE_READY)
			FSM_TEST_COND (TIME_OUT)
			FSM_TEST_COND (ACK)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("Listening")
			FSM_PROFILE_SECTION_OUT (state2_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, HANDLE_FLIT;, "FLIT_ARRIVAL", "HANDLE_FLIT", "Listening", "Listening", "tr_10", "Yu_wh_router_proc [Listening -> Listening : FLIT_ARRIVAL / HANDLE_FLIT]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, HANDLE_SWIRE;, "PSQUEUE_READY", "HANDLE_SWIRE", "Listening", "Listening", "tr_12", "Yu_wh_router_proc [Listening -> Listening : PSQUEUE_READY / HANDLE_SWIRE]")
				FSM_CASE_TRANSIT (2, 2, state2_enter_exec, HANDLE_TIMER;, "TIME_OUT", "HANDLE_TIMER", "Listening", "Listening", "tr_13", "Yu_wh_router_proc [Listening -> Listening : TIME_OUT / HANDLE_TIMER]")
				FSM_CASE_TRANSIT (3, 2, state2_enter_exec, HANDLE_ACK;, "ACK", "HANDLE_ACK", "Listening", "Listening", "tr_14", "Yu_wh_router_proc [Listening -> Listening : ACK / HANDLE_ACK]")
				FSM_CASE_TRANSIT (4, 2, state2_enter_exec, ;, "default", "", "Listening", "Listening", "tr_9", "Yu_wh_router_proc [Listening -> Listening : default / ]")
				}
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"Yu_wh_router_proc")
		}
	}




void
_op_Yu_wh_router_proc_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_Yu_wh_router_proc_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_Yu_wh_router_proc_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_Yu_wh_router_proc_svar function. */
#undef PGQ_RT_ACK
#undef inport_flit_buffer
#undef Routing_Table
#undef Neighbor_PORT_NODE_map
#undef combined_output_port
#undef combined_input_port
#undef Total_Node_Num
#undef This_Node_Number
#undef port_number
#undef Out_Node_Number
#undef My_Total_Node_Num
#undef Max_Deg
#undef In_Node_Number
#undef flit_counter
#undef DHF_buffer_time
#undef OUT_PORT_table
#undef IS_SINK_READY
#undef contain_DHF
#undef IN_PORT_table

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_Yu_wh_router_proc_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_Yu_wh_router_proc_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (Yu_wh_router_proc)",
		sizeof (Yu_wh_router_proc_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_Yu_wh_router_proc_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	Yu_wh_router_proc_state * ptr;
	FIN_MT (_op_Yu_wh_router_proc_alloc (obtype))

	ptr = (Yu_wh_router_proc_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "Yu_wh_router_proc [Init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_Yu_wh_router_proc_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	Yu_wh_router_proc_state		*prs_ptr;

	FIN_MT (_op_Yu_wh_router_proc_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (Yu_wh_router_proc_state *)gen_ptr;

	if (strcmp ("PGQ_RT_ACK" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->PGQ_RT_ACK);
		FOUT
		}
	if (strcmp ("inport_flit_buffer" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->inport_flit_buffer);
		FOUT
		}
	if (strcmp ("Routing_Table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Routing_Table);
		FOUT
		}
	if (strcmp ("Neighbor_PORT_NODE_map" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Neighbor_PORT_NODE_map);
		FOUT
		}
	if (strcmp ("combined_output_port" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->combined_output_port);
		FOUT
		}
	if (strcmp ("combined_input_port" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->combined_input_port);
		FOUT
		}
	if (strcmp ("Total_Node_Num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Total_Node_Num);
		FOUT
		}
	if (strcmp ("This_Node_Number" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->This_Node_Number);
		FOUT
		}
	if (strcmp ("port_number" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->port_number);
		FOUT
		}
	if (strcmp ("Out_Node_Number" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Out_Node_Number);
		FOUT
		}
	if (strcmp ("My_Total_Node_Num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->My_Total_Node_Num);
		FOUT
		}
	if (strcmp ("Max_Deg" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Max_Deg);
		FOUT
		}
	if (strcmp ("In_Node_Number" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->In_Node_Number);
		FOUT
		}
	if (strcmp ("flit_counter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->flit_counter);
		FOUT
		}
	if (strcmp ("DHF_buffer_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DHF_buffer_time);
		FOUT
		}
	if (strcmp ("OUT_PORT_table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->OUT_PORT_table);
		FOUT
		}
	if (strcmp ("IS_SINK_READY" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->IS_SINK_READY);
		FOUT
		}
	if (strcmp ("contain_DHF" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->contain_DHF);
		FOUT
		}
	if (strcmp ("IN_PORT_table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->IN_PORT_table);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

